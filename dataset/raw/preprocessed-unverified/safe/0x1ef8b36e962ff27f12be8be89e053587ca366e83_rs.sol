/**
 *Submitted for verification at Etherscan.io on 2019-11-01
*/

//generated by www.structuredeth.com/gift

pragma solidity ^0.4.26;













contract GiftOfCompound {
    
    using SafeMath for uint256;
    address theRecipient;
    address theSender;
    bytes PERM_HINT;
    uint256 initialCDaiAmount;
    uint256 theInterestRecipient;
    uint256 theInterestSender;

    CompoundERC20 cdai;
    
     modifier onlyGiftGroup() {
        if (msg.sender != theSender && msg.sender != theRecipient) {
            throw;
        }
        _;
    }
    
    //if smeone sends eth to this contract, throw it because it will just end up getting locked forever
    function() payable {
        throw;
    }
    
    
    
    
    
    

    constructor(address recipient, uint256 interestRecipient, uint256 interestSender) public payable {
        
        if(msg.value <= 0){
            throw;
        }
        
        theSender = msg.sender;
        theRecipient = recipient;
        
        theInterestSender = interestSender;
        theInterestRecipient = interestRecipient;
        
        //sum of the interest percentage must be 100 so everyone can get their funds
        if(theInterestRecipient.add(theInterestSender) != 100){
            throw;
        }
        
        
        
        initialCDaiAmount = giftWrap();
        
        
    }
    
    function transfer(address _to, uint256 _value) onlyGiftGroup external  returns(bool)  {
        
            //you are not sending more cdai than how much has been deposited.
            uint256 usersPercentage;
            if(msg.sender == theRecipient){
                usersPercentage = theInterestRecipient;
            }
            else{
                usersPercentage = theInterestSender;
                
            }
            
            
            uint256 daiSurplus= cdai.balanceOf(this).sub(initialCDaiAmount);
            uint256 amountDaiSurplusUserCanSend  = daiSurplus.mul(usersPercentage).div(100);
            
            uint256 requestedSurplus = _value.sub(initialCDaiAmount);
           
            if(_value <= initialCDaiAmount){
                require(cdai.transfer(_to, _value));
            }
            
            //you do not enough entitlement to the interest
            else if(requestedSurplus > amountDaiSurplusUserCanSend){
                
                throw;
            }
            else{
                 require(cdai.transfer(_to, _value));
            }
            
            //set initial amount to current amount so that people can keep withdrawing and we can know if they are entiteld to the interest amount
            initialCDaiAmount = cdai.balanceOf(this);
            
        
            return true;
    }
        
    
    function giftWrap() internal returns (uint256){
      
        ERC20 dai = ERC20(0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359);
        address kyberProxyAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
        IKyberNetworkProxy kyberProxy = IKyberNetworkProxy(kyberProxyAddress);
        cdai = CompoundERC20(0xf5dce57282a584d2746faf1593d3121fcac444dc);
        uint256 ethAmount1 = msg.value;
        PERM_HINT = "PERM";
        ERC20 eth = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);
        uint daiAmount = kyberProxy.tradeWithHint.value(ethAmount1)(eth, ethAmount1, dai, this, 8000000000000000000000000000000000000000000000000000000000000000, 0, 0x0000000000000000000000000000000000000004, PERM_HINT);
        dai.approve(address(cdai), 8000000000000000000000000000000000000000000000000000000);
        cdai.mint(daiAmount);
        
        uint256 cdaiAmount = cdai.balanceOf(this);
        return cdaiAmount;
    }
    
    function amountEntitledTo(address qAddress) constant external returns (uint256){
            uint256 usersPercentage;
            if(qAddress== theRecipient){
                usersPercentage = theInterestRecipient;
            }
            else if (qAddress == theSender){
                usersPercentage = theInterestSender;
                
            }
            else{
                return 0;
            }
            
            
            uint256 daiSurplus= cdai.balanceOf(this).sub(initialCDaiAmount);
            uint256 amountDaiSurplusUserCanSend  = daiSurplus.mul(usersPercentage).div(100);
            
            uint256 amountEntitledTo = initialCDaiAmount.add(daiSurplus);
            return amountEntitledTo;
    }
    
    function getRecipient() constant external returns (address){
        return theRecipient;
    }
    
    function getSender() constant external returns (address){
        return theSender;
    }
    
    function percentageInterestEntitledTo(address qAddress) constant external returns (uint256){
            uint256 usersPercentage;
            if(qAddress== theRecipient){
                usersPercentage = theInterestRecipient;
            }
            else if (qAddress == theSender){
                usersPercentage = theInterestSender;
                
            }
            else{
                return 0;
            }
            
           return usersPercentage;
    }
    
    
   
    
    function currentGiftAmount() constant external returns (uint256){
        uint256 cDaiMinted = cdai.balanceOf(this);
        return cDaiMinted;
    }
}