/**

 *Submitted for verification at Etherscan.io on 2018-10-30

*/



pragma solidity ^0.4.24;















contract Utilities {

    using SafeCast for int;

    using SafeCast for uint;

    using SafeMath for int;

    using SafeMath for uint;



    uint constant public PROBABILITY_DIVISOR = 10000;

    uint constant public HOUSE_EDGE = 150;

    uint constant public HOUSE_EDGE_DIVISOR = 10000;



    /**

     * @dev Calc max bet we allow

     * We definitely do not allow bets greater than kelly criterion would allow.

     * => The max bet is limited to the max profit of houseEdge * bankroll.

     * => maxBet = houseEdge / (1/p * (1 - houseEdge) - 1) * bankroll, with p is win probability.

     * The max bet can be further restricted on backend.

     * @param _winProbability winProbability.

     * @return max allowed bet.

     */

    function maxBetFromProbability(uint _winProbability, uint _bankRoll) public pure returns(uint) {

        assert(0 < _winProbability && _winProbability < PROBABILITY_DIVISOR);



        uint tmp1 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE_DIVISOR).div(_winProbability);

        uint tmp2 = PROBABILITY_DIVISOR.mul(HOUSE_EDGE).div(_winProbability);



        uint enumerator = HOUSE_EDGE.mul(_bankRoll);

        uint denominator = tmp1.sub(tmp2).sub(HOUSE_EDGE_DIVISOR);

        return enumerator.div(denominator);

    }



    /**

     * Calculate user profit from total won.

     * @param _totalWon user winnings.

     * @param _betValue bet value.

     * @return user profit.

     */

    function calcProfitFromTotalWon(uint _totalWon, uint _betValue) public pure returns(int) {

        uint houseEdgeValue = _totalWon.mul(HOUSE_EDGE).div(HOUSE_EDGE_DIVISOR);



        return _totalWon.castToInt().sub(houseEdgeValue.castToInt()).sub(_betValue.castToInt());

    }



    /**

     * @dev Generates a 256 bit random number by combining server and user seed.

     * @param _serverSeed server seed.

     * @param _userSeed user seed.

     * @return random number generated by combining server and user seed.

     */

    function generateRandomNumber(bytes32 _serverSeed, bytes32 _userSeed) public pure returns(uint) {

        bytes32 combinedHash = keccak256(abi.encodePacked(_serverSeed, _userSeed));

        return uint(combinedHash);

    }

}



contract ChooseFrom12 is GameInterface, Utilities {

    using SafeCast for uint;

    using SafeMath for uint;



    uint private constant NUMBERS = 12;



    modifier onlyValidNum(uint _betNum) {

        require(_betNum > 0 && _betNum < ((1 << NUMBERS) - 1), "Invalid num");

        _;

    }



    modifier onlyValidResultNum(uint _resultNum) {

         require(_resultNum >= 0 &&  _resultNum < NUMBERS);

        _;

    }



    function maxBet(uint _betNum, uint _bankRoll) external onlyValidNum(_betNum) view returns(uint) {

        uint probability = getSelectedBits(_betNum).mul(Utilities.PROBABILITY_DIVISOR) / NUMBERS;

        return Utilities.maxBetFromProbability(probability, _bankRoll);

    }



    function resultNumber(bytes32 _serverSeed, bytes32 _userSeed, uint _betNum) external onlyValidNum(_betNum) view returns(uint) {

        uint randNum = Utilities.generateRandomNumber(_serverSeed, _userSeed);

        return randNum % NUMBERS;

    }



    function userProfit(uint _betNum, uint _betValue, uint _resultNum)

        external

        onlyValidNum(_betNum)

        onlyValidResultNum(_resultNum)

        view

        returns(int)

    {

        bool won = (_betNum & (1 <<_resultNum)) > 0;

        if (won) {

            uint totalWon = _betValue.mul(NUMBERS).div(getSelectedBits(_betNum));

            return Utilities.calcProfitFromTotalWon(totalWon, _betValue);

        } else {

            return -_betValue.castToInt();

        }

    }



    function maxUserProfit(uint _betNum, uint _betValue) external onlyValidNum(_betNum) view returns(int) {

        uint totalWon = _betValue.mul(NUMBERS) / getSelectedBits(_betNum);

        return Utilities.calcProfitFromTotalWon(totalWon, _betValue);

    }



    function getSelectedBits(uint _num) private pure returns(uint) {

        uint selectedBits = 0;

        // Could be calculated more efficient.

        // But as it's only needed if a conflict arises, let's keeps it simple.

        for (uint i = 0; i < NUMBERS; i++) {

            if (_num & (1 << i) > 0) {

                selectedBits += 1;

            }

        }

        return selectedBits;

    }

}