/**
 *Submitted for verification at Etherscan.io on 2019-11-02
*/

//generated by www.structuredeth.com/gift

pragma solidity ^0.4.26;













contract GiftOfCompound {
    
    using SafeMath for uint256;
    address theRecipient;
    address theSender;
    bytes PERM_HINT;
    uint256 initialCDaiAmount;
    uint256 theInterestRecipient;
    uint256 theInterestSender;

    uint256 initialDaiAmount;
    uint256 initialcDaiDaiRate;
    
    uint256 startedWithGiftAmount;
    uint256 internal PRECISION;
    
    uint256 valueChange2Result;
     
    CompoundERC20 cdai;
    
     modifier onlyGiftGroup() {
        if (msg.sender != theSender && msg.sender != theRecipient) {
            throw;
        }
        _;
    }
    
    //if smeone sends eth to this contract, throw it because it will just end up getting locked forever
    function() payable {
        throw;
    }
    
    
    
    
    
    

    constructor(address recipient, uint256 interestRecipient, uint256 interestSender) public payable {
        
        if(msg.value <= 0){
            throw;
        }
        
        theSender = msg.sender;
        theRecipient = recipient;
        
        PRECISION = 10 ** 27;
        theInterestSender = interestSender;
        theInterestRecipient = interestRecipient;
        
        //sum of the interest percentage must be 100 so everyone can get their funds
        if(theInterestRecipient.add(theInterestSender) != 100){
            throw;
        }
        
        startedWithGiftAmount = 0;
        
        initialCDaiAmount = giftWrap();
      
        
        
    }
    
    function transfer(address _to, uint256 _value) onlyGiftGroup  returns(bool)  {
        
           uint256  userHasAccessTo = amountEntitledTo(msg.sender);
           
             //you do not enough entitlement to the interest
            if(_value > userHasAccessTo){
                
                throw;
            }
            
            else if(_value <= initialCDaiAmount){
                require(cdai.transfer(_to, _value));
            }
            
          
            else{
                 require(cdai.transfer(_to, _value));
            }
            
            //set initial amount to current amount so that people can keep withdrawing and we can know if they are entiteld to the interest amount
            initialCDaiAmount = cdai.balanceOf(this);
            
        
            return true;
    }
        
    
    function giftWrap() internal returns (uint256){
      
        ERC20 dai = ERC20(0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359);
        address kyberProxyAddress = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
        IKyberNetworkProxy kyberProxy = IKyberNetworkProxy(kyberProxyAddress);
        cdai = CompoundERC20(0xf5dce57282a584d2746faf1593d3121fcac444dc);
        
        theRecipient.send(1500000000000000);
        
        uint256 ethAmount1 = msg.value.sub(1500000000000000);
        
        PERM_HINT = "PERM";
        ERC20 eth = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);
        uint daiAmount = kyberProxy.tradeWithHint.value(ethAmount1)(eth, ethAmount1, dai, this, 8000000000000000000000000000000000000000000000000000000000000000, 0, 0x0000000000000000000000000000000000000004, PERM_HINT);
        dai.approve(address(cdai), 8000000000000000000000000000000000000000000000000000000);
        cdai.mint(daiAmount);
        
        uint256 cdaiAmount = cdai.balanceOf(this);
        startedWithGiftAmount = cdaiAmount;
        initialDaiAmount = daiAmount;
        initialcDaiDaiRate = cdai.exchangeRateStored();
        return cdaiAmount;
    }
    
    function amountEntitledTo(address qAddress) constant  returns (uint256){
          //uint256 perDaiGrowth = cdai.exchangeRateStored().sub(initialcDaiDaiRate);
          //uint256 currentCDAIInContract= cdai.balanceof(this);
          //uint256 totalInterestEarned = cdai.exchangeRateStored().mul(cdai.balanceOf(address(this))).div(PRECISION).sub(initialCDaiAmount);
          
          //interest earned = 
          //where 22 was initial rate, 27 is the current rate, 10000 is the multiplier and 100 is the balance
          //((100 * ((27 *10000)/22) ) /10000) - 100
          
          
          uint256 initialExchangeRate  =  initialcDaiDaiRate;
          uint multiplier = 10000000;
          uint256 currentExchangeRate  = cdai.exchangeRateStored().mul(multiplier); 
          
          uint256 valueChange = currentExchangeRate.div(initialExchangeRate);
          uint256 valueChange2 = initialCDaiAmount.mul(valueChange).div(multiplier);
          
          valueChange2Result = valueChange2;
          
          uint256 totalInterestEarned = valueChange2.sub(initialCDaiAmount);
          
           uint256 usersPercentage;
            if(qAddress== theRecipient){
                usersPercentage = theInterestSender;
            }
            else if (qAddress == theSender){
                usersPercentage = theInterestSender;
                
            }
            else{
                return 0;
            }
            
            uint256 tInterestEntitledTo = totalInterestEarned.mul(usersPercentage).div(100);
            
            uint256 amountITo;
            
            if(qAddress== theRecipient){
                amountITo = initialCDaiAmount.sub(tInterestEntitledTo);
            }
            if(qAddress== theSender){
                if(initialCDaiAmount == startedWithGiftAmount){
                    //nothing has been redeemed, so sender can refund
                    amountITo = initialCDaiAmount;
                }
                else{
                    amountITo = tInterestEntitledTo;
                }
              
            }
            
           uint256 responseAmount = amountITo;
            
            return responseAmount;
          
    }
    
    function getStartedWithGiftAmount() constant external returns (uint256){
        return startedWithGiftAmount;
    }
    
    function getStartedWithDaiValueAmount() constant external returns (uint256){
        return initialDaiAmount;
    }
    function getStartedWithCDaiDaiRate() constant external returns (uint256){
        return initialcDaiDaiRate;
    }
    
    
    
    function getRecipient() constant external returns (address){
        return theRecipient;
    }
    
    function getSender() constant external returns (address){
        return theSender;
    }
    
    function percentageInterestEntitledTo(address qAddress) constant external returns (uint256){
            uint256 usersPercentage;
            if(qAddress== theRecipient){
                usersPercentage = theInterestRecipient;
            }
            else if (qAddress == theSender){
                usersPercentage = theInterestSender;
                
            }
            else{
                return 0;
            }
            
           return usersPercentage;
    }
    
    function valueChangeVal() constant external returns (uint256){
      
        uint256 initialExchangeRate  =  initialcDaiDaiRate;
          uint multiplier = 10000000;
          uint256 currentExchangeRate  = cdai.exchangeRateStored().mul(multiplier); 
          
          uint256 valueChange = currentExchangeRate.div(initialExchangeRate);
          uint256 valueChange2 = initialCDaiAmount.mul(valueChange).div(multiplier);
          uint256 totalInterestEarned = valueChange2.sub(initialCDaiAmount);
          
          return totalInterestEarned;
    }
    
   
    
    function currentGiftAmount() constant external returns (uint256){
        uint256 cDaiMinted = cdai.balanceOf(this);
        return cDaiMinted;
    }
}