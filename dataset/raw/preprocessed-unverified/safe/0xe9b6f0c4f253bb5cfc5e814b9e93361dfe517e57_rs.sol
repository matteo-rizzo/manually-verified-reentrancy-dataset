// §ä§Ö§Ü§å§ë§Ñ§ñ §Ó§Ö§â§ã§Ú§ñ - 9 §ä§Ö§ã§ä§à§Ó§Ñ§ñ §Õ§Ý§ñ §â§Ñ§Ù§Ó§Ö§â§ä§í§Ó§Ñ§ß§Ú§ñ §Ó Rinkeby

// §Õ§à§Ò§Ñ§Ó§Ý§Ö§ß§í §Ü§à§Þ§Þ§Ö§ß§ä§í §Ó require

// §Ú§ã§á§â§Ñ§Ó§Ý§Ö§ß§Ñ §æ-§Ú§ñ refund

// §Ò§Ý§à§Ü§Ú§â§à§Ó§Ü§Ú §á§Ö§â§Ö§Ó§à§Õ§à§Ó §ã§Õ§Ö§Ý§Ñ§ß§í §ß§Ñ §Ó§Ö§ã§î §á§Ö§â§Ú§à§Õ ICO §Ú Crowdsale

// §Õ§à§Ò§Ñ§Ó§Ý§Ö§ß §Ý§à§Ô §Ó refund

// §Õ§à§Ò§Ñ§Ó§Ý§Ö§ß§í §æ§å§ß§Ü§è§Ú§Ú §Ò§Ý§à§Ü§Ú§â§à§Ó§Ü§Ú\§â§Ñ§Ù§Ò§Ý§à§Ü§Ú§â§à§Ó§Ü§Ú §Ó§ß§Ö§ê§ß§Ú§ç §á§Ö§â§Ö§Ó§à§Õ§à§Ó §Ó §â§Ñ§Ò§à§é§Ö§Þ §â§Ö§Ø§Ú§Þ§Ö §Ü§à§ß§ä§â§Ñ§Ü§ä§Ñ

// §Õ§Ý§ñ §Ó§à§Ù§Þ§à§Ø§ß§à§ã§ä§Ú §â§Ñ§ã§é§Ö§ä§Ñ §Õ§Ú§Ó§Ú§Õ§Ö§ß§Õ§à§Ó

// CRYPT Token = > CRYPT

// CRTT => CRT

// §Ú§Ù§Þ§Ö§ß§Ö§ß§í §æ-§è§Ú§Ú §â§Ñ§Ù§Õ§Ñ§é§Ú §ä§à§Ü§Ö§ß§à§Ó. §Ò§Ö§ã§á§Ý§Ñ§ä§ß§à §â§Ñ§Ù§Õ§Ñ§ä§î §ä§à§Ü§Ö§ß§í §Þ§à§Ø§ß§à §ä§à§Ý§î§Ü§à §ã 4-§ç §Ù§Ñ§â§Ö§Ù§Ö§â§Ó§Ú§â§à§Ó§Ñ§ß§ß§í§ç §Ñ§Õ§â§Ö§ã§à§Ó

// §Ó fallback §æ§å§ß§Ü§è§Ú§ð §Õ§à§Ò§Ñ§Ó§Ý§Ö§ß §Ò§Ý§à§Ü §â§Ñ§ã§é§Ö§ä§Ñ §Õ§Ý§Ú§ä§Ö§Ý§î§ß§à§ã§ä§Ú §á§Ö§â§Ú§à§Õ§à§Ó, §á§Ñ§å§Ù §Þ§Ö§Ø§Õ§å §á§Ö§â§Ú§à§Õ§Ñ§Þ§Ú 

// §Ú §Ñ§Ó§ä§à§Þ§Ñ§ä§Ú§é§Ö§ã§Ü§à§Û §ã§Þ§Ö§ß§í §á§Ö§â§Ú§à§Õ§à§Ó §á§à §à§Ü§à§ß§é§Ñ§ß§Ú§Ú §Ü§à§ß§ä§â§à§Ý§î§ß§à§Ô§à §Ó§â§Ö§Þ§Ö§ß§Ú (§á§Ñ§å§Ù§Ñ=30 §ã§å§ä§à§Ü)



//- §­§Ú§Þ§Ú§ä§í §á§à §à§Ò§ì§Ö§Þ§å 0.4 ETH = 2 000 §ä§à§Ü§Ö§ß§à§Ó

//- §­§Ú§Þ§Ú§ä§í §á§à §Ó§â§Ö§Þ§Ö§ß§Ú 1 §³§µ§´§¬§ª 

//- §±§Ñ§å§Ù§Ñ §Þ§Ö§Ø§Õ§å §ã§ä§Ñ§Õ§Ú§ñ§Þ§Ú - 1 §ã§å§ä§Ü§Ú 

//* §®§ª§¯§ª§®§¡§­§¾§¯§½§« §±§­§¡§´§¦§¨ §¯§¡ PRESALE 0.1 ETH 

//* §®§¡§¬§³§ª§®§¡§­§¾§¯§½§« §±§­§¡§´§¦§¨ §¯§¡ PREICO 0.1 ETH

// §£§ã§Ö§Ô§à §Ó§í§á§å§ë§Ö§ß§à = 50 000 §ä§à§Ü§Ö§ß§à§Ó

// HardCap 40% = 20 000 §ä§à§Ü§Ö§ß§à§Ó = 4 ETH







pragma solidity ^0.4.23;





contract ERC20Basic {

    function totalSupply() public view returns (uint256);

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

}



contract ERC20 is ERC20Basic {

    function allowance(address owner, address spender)

        public view returns (uint256);



    function transferFrom(address from, address to, uint256 value)

        public returns (bool);



    function approve(address spender, uint256 value) public returns (bool);

    event Approval(

    address indexed owner,

    address indexed spender,

    uint256 value

    );

}















contract BasicToken is ERC20Basic {

    using SafeMath for uint256;



    mapping(address => uint256) balances;



    uint256 totalSupply_;



    function totalSupply() public view returns (uint256) {

        return totalSupply_;

    }



    function transfer(address _to, uint256 _value) public returns (bool) {

        require(_to != address(0));

        require(_value <= balances[msg.sender]);



        balances[msg.sender] = balances[msg.sender].sub(_value);

        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);

        return true;

    }

  

    function balanceOf(address _owner) public view returns (uint256) {

        return balances[_owner];

    }



}





contract StandardToken is ERC20, BasicToken {



    mapping (address => mapping (address => uint256)) internal allowed;



    function transferFrom(

        address _from,

        address _to,

        uint256 _value

    )

        public

        returns (bool)

    {

        require(_to != address(0));

        require(_value <= balances[_from]);

        require(_value <= allowed[_from][msg.sender]);



        balances[_from] = balances[_from].sub(_value);

        balances[_to] = balances[_to].add(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;

    }





    function approve(address _spender, uint256 _value) public returns (bool) {

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;

    }





    function allowance(

        address _owner,

        address _spender

    )

    public

    view

    returns (uint256)

    {

        return allowed[_owner][_spender];

    }





    function increaseApproval(

        address _spender,

        uint _addedValue

    )

    public

    returns (bool)

    {

        allowed[msg.sender][_spender] = (

        allowed[msg.sender][_spender].add(_addedValue));

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }





    function decreaseApproval(

        address _spender,

        uint _subtractedValue

    )

        public

        returns (bool)

    {

        uint oldValue = allowed[msg.sender][_spender];

        if (_subtractedValue > oldValue) {

            allowed[msg.sender][_spender] = 0;

        } else {

            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);

        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;

    }



}





contract CRYPTToken is StandardToken {

    string public constant name = "CRYPT Test Token";

    string public constant symbol = "CRTT";

    uint32 public constant decimals = 18;

    uint256 public INITIAL_SUPPLY = 50000 * 1 ether;

    address public CrowdsaleAddress;

    bool public lockTransfers = false;



    constructor(address _CrowdsaleAddress) public {

    

        CrowdsaleAddress = _CrowdsaleAddress;

        totalSupply_ = INITIAL_SUPPLY;

        balances[msg.sender] = INITIAL_SUPPLY;      

    }

  

    modifier onlyOwner() {

        // only Crowdsale contract

        require(msg.sender == CrowdsaleAddress);

        _;

    }



     // Override

    function transfer(address _to, uint256 _value) public returns(bool){

        if (msg.sender != CrowdsaleAddress){

            require(!lockTransfers, "Transfers are prohibited in ICO and Crowdsale period");

        }

        return super.transfer(_to,_value);

    }



     // Override

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool){

        if (msg.sender != CrowdsaleAddress){

            require(!lockTransfers, "Transfers are prohibited in ICO and Crowdsale period");

        }

        return super.transferFrom(_from,_to,_value);

    }

     

    function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){

        require (balances[_from] >= _value);

        balances[_from] = balances[_from].sub(_value);

        balances[CrowdsaleAddress] = balances[CrowdsaleAddress].add(_value);

        emit Transfer(_from, CrowdsaleAddress, _value);

        return true;

    }



    function lockTransfer(bool _lock) public onlyOwner {

        lockTransfers = _lock;

    }







    function() external payable {

        // The token contract don`t receive ether

        revert();

    }  

}